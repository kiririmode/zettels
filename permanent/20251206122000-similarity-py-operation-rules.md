---
id: 2025-12-06-122000
title: similarity-py を実務で使うための運用ルール
created: 2025-12-06 12:20:00
updated: 2025-12-06 12:20:00
tags:
  - zettel
  - method
  - similarity-py
  - ci
source:
  type: article
  ref: "https://kiririmode.hatenablog.jp/entry/20250706/1751813841"
---

## 要約（Summary）

- similarity-pyは類似メソッドを検出する実用ツール。運用では閾値と最小行数を組み合わせ、誤検出を抑えつつAIと連携してリファクタを行うのが有効。

## 本文（Body）

このノートは similarity-py を継続運用するための実務ルール集。ポイントは「しきい値の決め方」「false-positiveの扱い」「CIとの連携」「AIとの役割分担」である。

運用ルール（推奨）

1. 初期閾値: similarity >= 0.8、min-lines >= 8。まずは保守的に運用して誤検出を抑える。
2. フォルダスコープ: まずは同一モジュール内で実行し、横断実行はステージングでのみ有効化する。
3. 分類フロー:
   - 自動検出→AIによる“意図的類似か否か”判定→不要なら記録してスキップ→要なら自動リファクタ案作成
4. エスカレーション: AIでも判定不能なケースはチームのリファクタ議論用スレッドへエスカレート。

CLI例と出力解釈

```tcsh
similarity-py src/vtt2minutes/ --threshold 0.8 --min-lines 8

# 出力例の解釈
# Similarity: 80.61% -> 要検討（依存がなければ統合候補）
# Similarity: 96.75% -> 高確度の重複。自動提案でOKが出る場合が多い
```

誤判定への対処

- テンプレート: AIが "意図的な類似" と判断した理由を必ずPRコメントに残すルール。
- 定期的（2週）に誤検出例を人がレビューして閾値やフィルタを微調整する。

自動化の実装ヒント

- 差分ベースで実行する: 新しいPRの差分のみを対象にして実行するとノイズが減る。
- 結果はJSONで保存して可視化（ダッシュボード）する。

プロンプト例（AIに判断させるとき）

- 短縮: "メソッドAとBは類似度0.82です。依存関係は〇〇。統合すべきか要約して下さい。"
- 詳細: "対象コードスニペット（A,B）を渡す。依存、パフォーマンス、API影響を考慮して統合の可否・具体的なrefactor案（コード）・対応ユニットテストを出して下さい。もし統合がリスクなら、その代替案（デコレータや共通ユーティリティ抽出）を提示して下さい。"

反論・限界

- similarity-pyは構文や意味の揺らぎに弱い場合がある（特に動的型のコード）。テストで挙動を保証できないケースは自動リファクタを避けるべき。

## 関連ノート（Links）

- [[20251206121000-ai-lizard-similarity-workflow|AI＋Lizard＋similarity-pyワークフローでコード発散を防ぐ]] 実際のCIワークフロー
- [[20251129181131-deltatocumulative-config-arguments|deltatocumulative Processor の設定引数]] 設定・引数の設計原則
- [[20251129160320-ai-task-granularity|AIへのタスク粒度と効率の関係]] AIに渡すタスクの粒度設計

## To-Do / 次に考えること

- [ ] リポジトリで差分実行のスクリプトを作る（PRトリガー）
- [ ] 2週間の誤判定サマリを作成して閾値を見直す
